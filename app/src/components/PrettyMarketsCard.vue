this "cool markets" card was generated by AI LOL Horrible, just how it will work.

<template>
  <div
    ref="cardRef"
    class="w-full max-w-2xl bg-gradient-to-br from-black to-soft-black border-border-light border-2 backdrop-blur-sm relative overflow-hidden rounded-lg"
  >
    <!-- Star loader contained within the card -->
    <div
      v-if="isLoading"
      ref="loaderRef"
      class="absolute inset-0 z-50 flex items-center justify-center bg-gradient-to-br from-off-black to-soft-black"
    >
      <svg
        ref="starRef"
        width="60"
        height="60"
        viewBox="0 0 24 24"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
        class="text-pure-white"
      >
        <path
          d="M12 2L15.09 8.26L22 9.27L17 14.14L18.18 21.02L12 17.77L5.82 21.02L7 14.14L2 9.27L8.91 8.26L12 2Z"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
        />
      </svg>
    </div>

    <div class="p-6">
      <!-- Header -->
      <div class="p-0 pb-4">
        <div class="flex justify-between items-start mb-2">
          <div class="flex items-center space-x-2">
            <div
              class="w-2 h-2 rounded-full animate-pulse"
              :class="timeRemaining === 'Market closed' ? 'bg-error' : 'bg-success'"
            />
            <span
              class="text-xsfont-medium"
              :class="timeRemaining === 'Market closed' ? 'text-error' : 'text-success'"
              >{{ timeRemaining === 'Market closed' ? 'Closed' : 'Active' }}</span
            >
          </div>
          <div class="flex items-center space-x-1 text-text-muted">
            <Clock class="h-3 w-3" />
            <span class="text-xs">{{ timeRemaining }}</span>
          </div>
        </div>
        <h2
          ref="titleRef"
          class="text-lg font-bold leading-tight text-text-primary mb-1"
          style="opacity: 0"
        >
          {{ market.title }}
        </h2>
        <p
          ref="descriptionRef"
          class="text-sm leading-relaxed text-text-secondary"
          style="opacity: 0"
        >
          {{ market.question }}
        </p>
      </div>

      <div class="p-0">
        <!-- Options Display -->
        <div class="space-y-4 mb-6">
          <div v-for="(option, index) in options" :key="option.name" class="space-y-2">
            <div class="flex justify-between items-center">
              <div class="flex items-center space-x-2">
                <span class="font-semibold text-text-primary">{{ option.name }}</span>
                <div :class="`w-3 h-3 rounded-full ${index === 0 ? 'bg-success' : 'bg-error'}`" />
              </div>
              <div class="text-right">
                <div
                  :ref="(el) => (percentRefs[index] = el)"
                  class="font-bold text-lg text-text-primary"
                  style="opacity: 0"
                >
                  0%
                </div>
                <div
                  :ref="(el) => (shareRefs[index] = el)"
                  class="text-xs text-text-muted"
                  style="opacity: 0"
                >
                  0 shares
                </div>
              </div>
            </div>
            <div class="relative">
              <div class="w-full bg-soft-black rounded-full h-3 overflow-hidden">
                <div
                  :ref="(el) => (progressRefs[index] = el)"
                  :class="`h-full rounded-full ${
                    index === 0
                      ? 'bg-gradient-to-r from-success to-success/80'
                      : 'bg-gradient-to-r from-error to-error/80'
                  }`"
                  style="width: 0%"
                />
              </div>
            </div>
          </div>
        </div>

        <!-- Bottom section with stats and button -->
        <div class="flex items-center justify-between">
          <!-- Market Stats - Bottom Left -->
          <div ref="statsRef" class="flex space-x-6" style="opacity: 0">
            <div class="text-center">
              <div class="flex items-center mb-1">
                <Users class="h-4 w-4 text-purple mr-1" />
                <div class="text-sm font-bold text-text-primary">
                  {{ agregatedData.totalShares.toLocaleString() }}
                </div>
              </div>
              <div class="text-xs text-text-muted">Total Shares</div>
            </div>
            <div class="text-center">
              <div class="flex items-center mb-1">
                <TrendingUp class="h-4 w-4 text-purple mr-1" />
                <div class="text-sm font-bold text-text-primary">
                  ${{ agregatedData.volume.toLocaleString() }}
                </div>
              </div>
              <div class="text-xs text-text-muted">Total Volume</div>
            </div>
          </div>

          <!-- Action Button - Bottom Right -->
          <button
            v-if="timeRemaining !== 'Market closed'"
            ref="buttonRef"
            class="bg-gradient-to-r from-purple to-purple-dark hover:from-purple-dark cursor-pointer hover:to-purple text-pure-white font-semibold shadow-lg hover:shadow-purple/25 transition-all duration-150 relative overflow-hidden px-8 py-3 rounded-lg"
            style="opacity: 0"
            @click="NavToMarket"
          >
            <div
              class="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent -translate-x-full hover:translate-x-full transition-transform duration-700"
            />
            <TrendingUp class="mr-2 h-4 w-4 inline" />
            Trade / View Chart
          </button>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted, nextTick } from 'vue'
import { gsap } from 'gsap'
import { Clock, Users, TrendingUp } from 'lucide-vue-next'
import type { Market } from '@/utils/Types'

const props = defineProps<{ market: Market }>()

const isLoading = ref(true)
const isContentVisible = ref(false)
const currentTime = ref(new Date())

// Template refs
const cardRef = ref<HTMLElement>()
const loaderRef = ref<HTMLElement>()
const starRef = ref<SVGElement>()
const titleRef = ref<HTMLElement>()
const descriptionRef = ref<HTMLElement>()
const progressRefs = ref<HTMLElement[]>([])
const percentRefs = ref<HTMLElement[]>([])
const shareRefs = ref<HTMLElement[]>([])
const buttonRef = ref<HTMLElement>()
const statsRef = ref<HTMLElement>()

const agregatedData = ref({
  volume: 0,
  totalShares: 0,
  option1: { volume: 0, shares: 0 },
  option2: { volume: 0, shares: 0 },
})

// Timer for countdown
let countdownInterval: NodeJS.Timeout | null = null

// Computed countdown
const timeRemaining = computed(() => {
  if (!props.market.projected_end) return 'No end date'

  const endDate = new Date(props.market.projected_end)
  const now = currentTime.value
  const timeDiff = endDate.getTime() - now.getTime()

  if (timeDiff <= 0) {
    return 'Market closed'
  }

  const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24))
  const hours = Math.floor((timeDiff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60))
  const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60))

  if (days > 0) {
    return `${days}d ${hours}h ${minutes}m`
  } else if (hours > 0) {
    return `${hours}h ${minutes}m`
  } else {
    return `${minutes}m`
  }
})

// Computed options with percentages
const options = computed(() => {
  const option1Percentage =
    agregatedData.value.totalShares > 0
      ? (agregatedData.value.option1.shares / agregatedData.value.totalShares) * 100
      : 0
  const option2Percentage =
    agregatedData.value.totalShares > 0
      ? (agregatedData.value.option2.shares / agregatedData.value.totalShares) * 100
      : 0

  return [
    {
      name: props.market.options.Option1,
      volume: agregatedData.value.option1.shares,
      percentage: option1Percentage,
    },
    {
      name: props.market.options.Option2,
      volume: agregatedData.value.option2.shares,
      percentage: option2Percentage,
    },
  ]
})

// Calculate aggregated data
const calculateAggregatedData = () => {
  // Reset data
  agregatedData.value = {
    volume: 0,
    totalShares: 0,
    option1: { volume: 0, shares: 0 },
    option2: { volume: 0, shares: 0 },
  }

  // Calculate Option 1 data
  props.market.shares.Option1.forEach((Option1Share) => {
    agregatedData.value.option1.volume += Option1Share.BoughtValue
    agregatedData.value.option1.shares += 1
    agregatedData.value.volume += Option1Share.BoughtValue
    agregatedData.value.totalShares += 1
  })

  // Calculate Option 2 data
  props.market.shares.Option2.forEach((Option2Share) => {
    agregatedData.value.option2.volume += Option2Share.BoughtValue
    agregatedData.value.option2.shares += 1
    agregatedData.value.volume += Option2Share.BoughtValue
    agregatedData.value.totalShares += 1
  })
}

// Start countdown timer
const startCountdown = () => {
  countdownInterval = setInterval(() => {
    currentTime.value = new Date()
  }, 1000) // Update every second
}

// Set initial states immediately when component mounts
const setInitialStates = () => {
  if (!cardRef.value) return

  const ctx = gsap.context(() => {
    // Set all initial states immediately to prevent flash
    gsap.set(titleRef.value, { y: 20, opacity: 0 })
    gsap.set(descriptionRef.value, { y: 20, opacity: 0 })
    gsap.set(progressRefs.value, { width: 0 })
    gsap.set(percentRefs.value, { opacity: 0 })
    gsap.set(shareRefs.value, { opacity: 0 })
    gsap.set(statsRef.value, { y: 20, opacity: 0 })
    gsap.set(buttonRef.value, { y: 20, opacity: 0 })

    // Set initial text values
    percentRefs.value.forEach((el) => {
      if (el) el.textContent = '0%'
    })
    shareRefs.value.forEach((el) => {
      if (el) el.textContent = '0 shares'
    })
  }, cardRef.value)
}

// Start loading animation
const startLoadingAnimation = () => {
  if (starRef.value) {
    gsap.to(starRef.value, {
      rotation: 360,
      repeat: -1,
      duration: 1.5,
      ease: 'linear',
    })
  }

  // Simulate loading time
  setTimeout(() => {
    if (loaderRef.value) {
      gsap.to(loaderRef.value, {
        opacity: 0,
        duration: 0.5,
        onComplete: () => {
          isLoading.value = false
          isContentVisible.value = true
        },
      })
    }
  }, 2000)
}

// Content animation sequence
const animateContent = () => {
  if (!cardRef.value || !isContentVisible.value) return

  const ctx = gsap.context(() => {
    // Animation sequence
    const tl = gsap.timeline({ delay: 0.3 })

    // Title and description
    tl.to(titleRef.value, {
      y: 0,
      opacity: 1,
      duration: 0.8,
      ease: 'power2.out',
    }).to(
      descriptionRef.value,
      {
        y: 0,
        opacity: 1,
        duration: 0.8,
        ease: 'power2.out',
      },
      '-=0.4',
    )

    // Show percentage and share text first - all at once
    tl.to(
      [...percentRefs.value, ...shareRefs.value],
      {
        opacity: 1,
        duration: 0.3,
      },
      '-=0.2',
    )

    // Progress bars and numbers - in parallel
    const progressTl = gsap.timeline()
    tl.add(progressTl, '-=0.1')

    // Setup counters for each option
    options.value.forEach((option, index) => {
      const counter = { percentage: 0, shares: 0 }

      // Animate progress bars in parallel
      progressTl.to(
        progressRefs.value[index],
        {
          width: `${option.percentage}%`,
          duration: 1.5,
          ease: 'power2.inOut',
        },
        0, // Start at the same time
      )

      // Animate counters in parallel
      progressTl.to(
        counter,
        {
          percentage: option.percentage,
          shares: option.volume,
          duration: 1.5,
          ease: 'power2.inOut',
          onUpdate: () => {
            // Update percentage text
            if (percentRefs.value[index]) {
              percentRefs.value[index].textContent = `${counter.percentage.toFixed(1)}%`
            }

            // Update shares text
            if (shareRefs.value[index]) {
              shareRefs.value[index].textContent =
                `${Math.round(counter.shares).toLocaleString()} shares`
            }
          },
        },
        0, // Start at the same time
      )
    })

    // Stats and button
    tl.to(
      statsRef.value,
      {
        y: 0,
        opacity: 1,
        duration: 0.8,
        ease: 'power2.out',
      },
      '-=0.6',
    ).to(
      buttonRef.value,
      {
        y: 0,
        opacity: 1,
        duration: 0.8,
        ease: 'power2.out',
      },
      '-=0.4',
    )

    // Button hover animations
    const button = buttonRef.value
    if (button) {
      button.addEventListener('mouseenter', () => {
        gsap.to(button, {
          scale: 1.02,
          duration: 0.2,
          ease: 'power2.out',
        })
      })

      button.addEventListener('mouseleave', () => {
        gsap.to(button, {
          scale: 1,
          duration: 0.2,
          ease: 'power2.out',
        })
      })
    }
  }, cardRef.value)
}

// Navigation function
const NavToMarket = () => {
  console.log(props.market.marketid)
  // Add your navigation logic here
}

onMounted(async () => {
  // Calculate data first
  calculateAggregatedData()

  // Start countdown timer
  startCountdown()

  // Wait for next tick to ensure DOM is ready
  await nextTick()

  // Set initial states
  setInitialStates()

  // Start loading animation
  startLoadingAnimation()
})

onUnmounted(() => {
  // Clean up countdown timer
  if (countdownInterval) {
    clearInterval(countdownInterval)
  }
})

// Watch for content visibility to start content animation
import { watch } from 'vue'
watch(isContentVisible, (newValue) => {
  if (newValue) {
    nextTick(() => {
      animateContent()
    })
  }
})
</script>
